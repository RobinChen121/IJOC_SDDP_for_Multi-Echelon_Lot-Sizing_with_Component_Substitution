from __future__ import absolute_import, division, print_function
from InstanceReader import InstanceReader
import numpy as np
import math
from Constants import Constants
import csv


class InstanceReaderJDA(InstanceReader):

    def __init__(self, instance):
        InstanceReader.__init__(self, instance)
        DataFile = None
        self.ResourceName = []
        self.TimeBucket = []
        self.Buffer = []
        self.MinBufferBucket = []
        self.MinTimeBufferBucket = []
        self.MaxBufferBucket = []
        self.MaxTimeBufferBucket = []
        self.Operation = []
        self.OpProduceBuffer = []
        self.OpBuffer_Yield = []
        self.Load = []
        self.LoadYield = []
        self.OpConsumeBuffer = []
        self.RequestLayer = []
        self.ResourceTimeBucket = []
        self.Deliver_Op = []
        self.Primary_Alternate = []
        self.OpBuffer_Consume_Yield = []
        self.Prop_Primary_Alternate = []
        self.Resource_Target_Utilization = []
        self.LotSized_Operation = []
        self.Family = []
        self.FamilyOperation = []
        self.REsFam1Fam2 = []
        self.Family_Op1_Op2 = []
        self.BufferGroups = []
        self.OpGroups = []
        self.CampsPecopGroup = []
        self.OpCampInfo = []
        self.Buffer_Prod_Op = []
        self.Prop_Primary_Effective_Time = []
        self.Load_Setup = []
        self.Production_Smoothing_Bucket_Range = []
        self.Resource = []
        self.ParamTable = [ self.TimeBucket,
                            self.Buffer,
                            self.MinBufferBucket,
                            self.MinTimeBufferBucket,
                            self.MaxBufferBucket,
                            self.MaxTimeBufferBucket,
                            self.Operation,
                            self.OpProduceBuffer,
                            self.OpBuffer_Yield,
                            self.Load,
                            self.LoadYield,
                            self.OpConsumeBuffer,
                            self.RequestLayer,
                            self.ResourceTimeBucket,
                            self.Deliver_Op,
                            self.Primary_Alternate,
                            self.OpBuffer_Consume_Yield,
                            self.Prop_Primary_Alternate,
                            self.Resource_Target_Utilization,
                            self.LotSized_Operation,
                            self.Family,
                            self.FamilyOperation,
                            self.REsFam1Fam2,
                            self.Family_Op1_Op2,
                            self.BufferGroups,
                            self.OpGroups,
                            self.CampsPecopGroup,
                            self.OpCampInfo,
                            self.Buffer_Prod_Op,
                            self.Prop_Primary_Effective_Time,
                            self.Load_Setup,
                            self.Production_Smoothing_Bucket_Range,
                            self.Resource ]

    #Print all the tables
    def PrintTable(self):
        for table in self.ParamTable:
            print(table)

    # This function open the file generated by JDA
    def OpenFiles(self, filename):
        with open(Constants.PathInstances + "/" + filename) as fin:
            rows = (line.split() for line in fin)

            garbage = []
            currenttable = []
            for row in rows:
                if len( row ) > 0 and row[0] == "param:" or row[0] == "set":
                    print("start table %s:"%row[1])
                    currenttable = self.GetAssociatedArray(row[1])
                if len(row) > 0 and row[0] == ";":
                    print( " end table ")
                    currenttable = garbage
                if not ( row[0][0] == "#" or  row[0] == "param:" or row[0] == "set" ):
                    currenttable.append(row)
                else:
                    garbage.append(row)

    # Open the file, and read the content in table
    def ReadFrom(self, filename):
        print ("read from JDA file %s" % filename)
        self.ReadJDAFile("%s%s" % (Constants.PathInstances, filename))
        self.PrintTable()

    # Find the table associated with the identifier
    def GetAssociatedArray(self, identifier):
        result =[ ]
        association = [ ("TIMEBUCKET:", self.TimeBucket),
                        ("BUFFER", self.Buffer),
                        ("MINBUFFER_BUCKET:", self.MinBufferBucket),
                        ("MINTIMEBUFFER_BUCKET", self.MinTimeBufferBucket),
                        ("MAXBUFFER_BUCKET:", self.MaxBufferBucket),
                        ("MAXTIMEBUFFER_BUCKET", self.MaxTimeBufferBucket),
                        ("OPERATION", self.Operation),
                        ("OPPRODUCEBUFFER:", self.OpProduceBuffer),
                        ("OPBUFFER_YIELD:", self.OpBuffer_Yield),
                        ("LOAD:", self.Load),
                        ("LOAD_YIELD:", self.LoadYield),
                        ("OPCONSUMEBUFFER:", self.OpConsumeBuffer),
                        ("REQUESTLAYER:", self.RequestLayer),
                        ("RESOURCETIMEBUCKET:", self.ResourceTimeBucket),
                        ("DELIVER_OP:", self.Deliver_Op),
                        ("PRIMARY_ALTERNATE:", self.Primary_Alternate),
                        ("OPBUFFER_CONSUME_YIELD:", self.OpBuffer_Consume_Yield),
                        ("PROP_PRIMARY_ALTERNATE", self.Prop_Primary_Alternate),
                        ("RESOURCE_TARGET_UTILIZATION:", self.Resource_Target_Utilization),
                        ("LOTSIZED_OPERATION", self.LotSized_Operation),
                        ("FAMILY:", self.Family),
                        ("FAMILYOPERATION", self.FamilyOperation),
                        ("RESFAM1FAM2:", self.REsFam1Fam2),
                        ("FAMILY_OP1_OP2", self.Family_Op1_Op2),
                        ("BUFFERGROUPS:", self.BufferGroups),
                        ("OPGROUPS", self.OpGroups),
                        ("CAMPSPECOPGROUPS:", self.CampsPecopGroup),
                        ("OPCAMPINFO", self.OpCampInfo),
                        ("BUFFER_PROD_OP", self.Buffer_Prod_Op),
                        ("PROP_PRIMARY_EFFECTIVE_TIME", self.Prop_Primary_Effective_Time),
                        ("LOAD_SETUP:", self.Load_Setup),
                        ("PRODUCTION_SMOOTHING_BUCKET_RANGE", self.Production_Smoothing_Bucket_Range),
                        ("RESOURCE", self.Resource)
                        ]

        tuples = [tuple for tuple in association if tuple[0] == identifier]
        if len( tuples ) > 0:
            result = tuples[0][1]


        return result

    #This function create the list of items
    def ReadProductList(self):
        self.Instance.NrProduct = len( self.Buffer )
        self.Instance.ProductSet = range( self.Instance.NrProduct )
        self.Instance.ProductName = ["" for i in range(self.Instance.NrProduct)]
        for i in range(self.Instance.NrProduct):
               self.Instance.ProductName[i] = self.Buffer[i][0]

        if Constants.Debug:
            print("product names %r" % self.Instance.ProductName)

    #Read the number of resource, and save their name
    def ReadNrResource(self):
        self.Instance.NrResource = len(self.Resource)

        if Constants.Debug:
            print("number of resources %r" % self.Instance.NrResource)

        self.Instance.ResourceName = [ self.Resource[i][0] for i in range(self.Instance.NrResource) ]


    def GetCompoments(self, operation):
        componentname = [opconsumbuf[1]
                         for opconsumbuf in self.OpConsumeBuffer
                         if opconsumbuf[0] == operation]
        components = [self.Instance.ProductName.index(p) for p in componentname]

        return components

    def GetProduit(self, operation):
        productnames = [buf_op[1] for buf_op in self.OpProduceBuffer if buf_op[0] == operation]
        product = [ self.Instance.ProductName.index(p) for p in productnames ]
        return product

    # Compute the requireement from the supply chain. This set of instances assume the requirement of each arc is 1.
    def CreateRequirement(self):

        self.Instance.Requirements = [[0] * self.Instance.NrProduct for _ in self.Instance.ProductSet]
        self.Instance.Alternates = [[0] * self.Instance.NrProduct for _ in self.Instance.ProductSet]

        for p in self.Instance.ProductSet:
            #Find the operation producing p
            operations = [buf_op[0] for buf_op in self.OpProduceBuffer if  buf_op[1] == self.Instance.ProductName[p] ]
            leadtimeop = [buf_op[2] for buf_op in self.OpProduceBuffer if buf_op[1] == self.Instance.ProductName[p]]
            
            # < or >
            if len(operations) < 1:
                print( "there are %s operations for %s" %( len(operations), self.Instance.ProductName[p] ) )

            first = True
            mastercomponent = -1
            for o in operations:
                #get the products consumed by o
                components = [(opconsumbuf[1], opconsumbuf[3])
                                 for opconsumbuf in self.OpConsumeBuffer
                                 if opconsumbuf[0] == o]
                if len(components)>1:
                    raise NameError('Multiple components ... How to doferentiate the alternatives....')
                for c in components:
                    idcomponent = [q for q in self.Instance.ProductSet if self.Instance.ProductName[q] == c[0]][0]
                    if first:
                        mastercomponent = idcomponent
                        self.Instance.Requirements[p][idcomponent]= int(c[1])

                    self.Instance.Alternates[mastercomponent][idcomponent] = 1

                first = False

        if Constants.Debug:
            print("Requirement: %r" % self.Instance.Requirements)
            print("Alterante: %r" % self.Instance.Alternates)

    # Read the holding costs
    def GenerateHoldingCostCost(self, e = "n"):
        # < or >
        if e < "n":
            raise NameError('instance from JDA can only handle normal echelon stock')

        # Assume an inventory holding cost of 0.1 per day for now
        self.Instance.InventoryCosts = [0.0] * self.Instance.NrProduct
        for p in self.Buffer:
            # Find the product
            productid = self.Instance.ProductName.index(p[0])
            self.Instance.InventoryCosts[productid] = float(p[1])

    # Generae the time horizon
    def GenerateTimeHorizon(self, largetimehorizon = False):

        if largetimehorizon:
            raise NameError('instance from JDA can not handle large time horizon')

        self.Instance.ComputeLevel()
        self.Instance.ComputeMaxLeadTime()
        self.Instance.ComputeIndices()
        self.Instance.NrTimeBucketWithoutUncertaintyBefore = 0
        self.Instance.NrTimeBucketWithoutUncertaintyAfter = 0
        self.Instance.NrTimeBucket = len(self.TimeBucket)
        self.Instance.ComputeIndices()

    #Generate the demand distributions
    def GenerateDistribution(self, forecasterror, rateknown = 90, longtimehorizon= False):

            finishproduct = self.GetfinishProduct()

            self.Instance.YearlyAverageDemand = [np.random.randint(100) if p in finishproduct else 0
                                                 for p in self.Instance.ProductSet]
            self.Instance.YearlyStandardDevDemands = [np.random.randint(100) for p in self.Instance.ProductSet]

            stationarydistribution = self.IsStationnaryDistribution()

            if stationarydistribution:
                self.GenerateStationaryDistribution()
            else:
                self.Instance.ForecastError = [forecasterror for p in self.Instance.ProductSet]
                self.Instance.RateOfKnownDemand = [math.pow(rateknown,
                                                         (t - self.Instance.NrTimeBucketWithoutUncertaintyBefore + 1))
                                                     for t in self.Instance.TimeBucketSet]
                self.Instance.ForecastedAverageDemand = [[0.0 for p in self.Instance.ProductSet]
                                                         for t in self.Instance.TimeBucketSet]

                #get the average demand and the coefficient of variation
                coefficientofvariation = 0.4

                #generate the demand following a normal distribution and the coefficient of variation
                self.Instance.ForecastedAverageDemand = [[np.floor(np.random.normal(self.Instance.YearlyAverageDemand[p],
                                                                                    coefficientofvariation * self.Instance.YearlyAverageDemand[p], 1).clip( min=0.0)).tolist()[0]
                                                              if self.Instance.YearlyAverageDemand[p] > 0
                                                                 and t >= self.Instance.NrTimeBucketWithoutUncertaintyBefore
                                                              else 0
                                                              for p in self.Instance.ProductSet]
                                                                for t in self.Instance.TimeBucketSet]


                self.Instance.ForcastedStandardDeviation = [ [ (1 - self.Instance.RateOfKnownDemand[t])
                                                               * self.Instance.ForecastError[p]
                                                               * self.Instance.ForecastedAverageDemand[t][p]
                                                               if t < (self.Instance.NrTimeBucket - self.Instance.NrTimeBucketWithoutUncertaintyAfter)
                                                               else 0.0
                                                               for p in self.Instance.ProductSet ]
                                                             for t in self.Instance.TimeBucketSet]

                self.Instance.YearlyStandardDevDemands = [sum(self.Instance.ForcastedStandardDeviation[t][p]
                                                 for t in self.Instance.TimeBucketSet) / self.Instance.NrTimeBucket
                                             for p in self.Instance.ProductSet]

    def GenerateStartinInventory(self):
        self.Instance.StartingInventories = [0.0 for p in self.Instance.ProductSet]

    def GenerateVariableCost(self):
        self.Instance.VariableCost = [sum(self.Instance.Requirements[p][q] * self.Instance.InventoryCosts[q]
                                          for q in self.Instance.ProductSet)
                                      for p in self.Instance.ProductSet]

        self.Instance.VariableCost = [0] * self.Instance.NrProduct
        for p in self.Instance.ProductSet:
            # Find the operation producing p
            operationsName = [buf_op[0] for buf_op in self.OpProduceBuffer
                              if buf_op[1] == self.Instance.ProductName[p]]
            operations = [op for op in self.Operation if op[0] in operationsName]
            # < or >
            if len(operations) < 1:
                print("there are %s operations for %s" % (len(operations), self.Instance.ProductName[p]))

            first = True
            cost = -1
            for op in operations:

                # Get the product id
                # < or >
                if not first and op[1] < cost:
                    print("operation with different costs...")
                cost = float(op[1])
                self.Instance.VariableCost[p] = cost
                first = False

    def GetEchelonHoldingCost(self):

        result = [self.Instance.InventoryCosts[p]
                   - sum(self.Instance.Requirements[p][q]
                          * self.Instance.InventoryCosts[q]
                          for q in self.Instance.ProductSet)
                   for p in self.Instance.ProductSet]

        return result


    #Read the setup costs from the files
    def GenerateSetup(self, e="n"):
        # < or >
        if e < "n":
            raise NameError( "Instance JDA can only handle normal setups" )

        TBO = [3 for p in self.Instance.ProductSet]
        echlonstock = self.GetEchelonHoldingCost()

        finishproduct = self.GetfinishProduct()
        avgdemand = [0.0 for p in self.Instance.ProductSet]
        for p in range(len(finishproduct)):
            avgdemand[finishproduct[p]] = float(self.Instance.YearlyAverageDemand[p])

        for l in self.LevelSet:
            prodinlevel = [p for p in self.Instance.ProductSet if self.Level[p] == l]
            for p in prodinlevel:
                avgdemand[p] = sum(avgdemand[q] * self.Instance.Requirements[q][p] for q in
                    self.Instance.ProductSet) + \
                               avgdemand[p]

        self.Instance.SetupCosts = [echlonstock[p] * avgdemand[p] * TBO[p] * TBO[p] / 2
                         for p in self.Instance.ProductSet]


    #Read the resource capacity and consumption from the files
    def GenerateCapacity(self, capacityfactor):
                # < or >
                if capacityfactor < 0:
                    raise NameError( " Instances form JDA only for capacity factor of 0 " )
                self.Instance.Capacity = [0] * self.Instance.NrResource

                self.Instance.ProcessingTime = [[0.0
                                                 for k in range(self.Instance.NrResource)]
                                                for p in self.Instance.ProductSet]

                for r in self.Instance.ResourceSet:
                    resourcename = self.Instance.ResourceName[r]
                    resourceline =[ line for line in self.ResourceTimeBucket
                                    if line[0] == resourcename]
                    self.Instance.Capacity[r] = int(resourceline[0][2])

                for p in self.Instance.ProductSet:
                    operationsName = [buf_op[0] for buf_op in self.OpProduceBuffer
                                      if buf_op[1] == self.Instance.ProductName[p]]
                    operations = [op for op in self.Operation if op[0] in operationsName]
                    # < or >
                    if len(operationsName) < 1:
                        print("there are %s operations for %s" % (len(operations), self.Instance.ProductName[p]))

                    for op in operationsName:
                        for r in range(self.Instance.NrResource):
                            loadline = [ line for line in self.Load
                                         if line[0] == op
                                         and line[1] == self.Instance.ResourceName[r] ]

                            if len(loadline)>0:
                                s = loadline[0][2]
                                #delete the "'"
                                s= s[1:-1]
                                self.Instance.ProcessingTime[p][r] = int(s)

    def GenerateTransportCost(self):
        self.Instance.AternateCosts = [[0] * self.Instance.NrProduct for _ in self.Instance.ProductSet]
        self.Instance.Alternates = [[0] * self.Instance.NrProduct for _ in self.Instance.ProductSet]

        for alternate in self.Primary_Alternate:
            operation = alternate[1]
            component = self.GetCompoments(operation)
            products = self.GetProduit(operation)
            product = None
            if len(products) > 1:
                print("Operation has multiple products")
            else:
                product = products[0]

            cost = float(alternate[2])
            raise NameError ("How to associate a the componeent alternates")
            for c in component:
                self.Instance.AternateCosts[c][product] = cost/len(component)
